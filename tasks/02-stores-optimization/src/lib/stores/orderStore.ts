import { writable } from 'svelte/store';

// Базовые типы данных для нашего приложения
interface Product {
    id: number;
    name: string;
    price: number;
    quantity: number;
}

interface Order {
    products: Product[];
    total: number;
    status: 'pending' | 'processing' | 'completed';
}

/**
 * ЗАДАЧА 1: Оптимизация структуры stores
 * 
 * Сейчас у нас один большой store для всего заказа. Это создает несколько проблем:
 * 1. При любом изменении в заказе перерендериваются все компоненты, подписанные на store
 * 2. Сложно отследить, какие именно данные изменились
 * 3. Вычисляемые значения (например, total) пересчитываются при каждом изменении
 * 
 * Подумай:
 * - Может ли помочь разделение на несколько специализированных stores?
 * - Как использовать derived stores для вычисляемых значений?
 * - Где может пригодиться readable store для неизменяемых данных?
 */
export const orderStore = writable<Order>({
    products: [],
    total: 0,
    status: 'pending'
});

/**
 * ЗАДАЧА 2: Создание derived stores
 * 
 * Обрати внимание на то, как часто пересчитывается total:
 * - При каждом изменении количества любого продукта
 * - При добавлении/удалении продукта
 * - При изменении статуса заказа (хотя это не должно влиять на total)
 * 
 * Как можно использовать derived store, чтобы:
 * - Автоматически пересчитывать total только когда это действительно нужно?
 * - Кешировать результат вычислений?
 * - Обновлять UI только при реальных изменениях суммы?
 */

/**
 * ЗАДАЧА 3: Оптимизация методов обновления
 * 
 * Текущая реализация addProduct имеет несколько проблем:
 * 1. Создает новый массив при каждом обновлении
 * 2. Пересчитывает total внутри метода
 * 3. Не учитывает возможность добавления существующего продукта
 * 
 * Подумай:
 * - Как можно оптимизировать обновление массива products?
 * - Стоит ли выносить логику расчета total в отдельный derived store?
 * - Как обрабатывать кейс с добавлением существующего продукта?
 */
export function addProduct(product: Product) {
    orderStore.update(order => {
        const products = [...order.products, product];
        return {
            ...order,
            products,
            total: calculateTotal(products)
        };
    });
}

/**
 * ЗАДАЧА 4: Оптимизация вычислений
 * 
 * Функция calculateTotal вызывается слишком часто:
 * - При каждом изменении в корзине
 * - Даже когда изменения не влияют на сумму
 * 
 * Подумай:
 * - Можно ли мемоизировать результат?
 * - Как определить, действительно ли нужно пересчитывать сумму?
 * - Может ли помочь паттерн "производное состояние"?
 */
function calculateTotal(products: Product[]): number {
    return products.reduce((sum, product) => sum + product.price * product.quantity, 0);
}
