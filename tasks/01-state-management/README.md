# Менеджер задач с отменой действий и оптимизацией производительности

## Описание задачи

Разработать высокопроизводительный менеджер задач с поддержкой отмены действий, демонстрирующий глубокое понимание внутренних механизмов Svelte и принципов оптимизации.

## Цели обучения

### Технические навыки
- [ ] Создание и оптимизация Svelte stores
- [ ] Работа с производными stores (derived)
- [ ] Эффективное обновление состояния
- [ ] Правильная организация типов TypeScript
- [ ] Оптимизация производительности компонентов

### Паттерны и практики
- [ ] Реализация паттерна Command для undo/redo
- [ ] Оптимистичные обновления UI
- [ ] Дебаунс пользовательского ввода
- [ ] Мемоизация тяжёлых вычислений
- [ ] Работа с localStorage

### Собеседование
- [ ] Ответы на типичные вопросы по Svelte stores
- [ ] Объяснение reactive statements
- [ ] Обсуждение производительности
- [ ] Обоснование архитектурных решений

## Методические указания

### 1. Анализ требований

Перед началом работы ответьте на следующие вопросы:

1. Структура данных
   - Какая структура данных обеспечит наиболее быстрый доступ к задачам по ID?
   - Как организовать хранение истории действий для эффективного undo/redo?
   - Какие индексы нужны для быстрой фильтрации и поиска?

2. Работа с состоянием
   - Как избежать дублирования данных в разных частях приложения?
   - Какие части состояния должны быть реактивными?
   - Как минимизировать количество обновлений состояния?

3. Производительность
   - Какие операции могут стать узким местом при большом количестве задач?
   - Как определить необходимость виртуализации списка?
   - Какие метрики производительности критичны для UX?

### 2. Проектирование архитектуры

Ответьте на вопросы по каждому компоненту системы:

#### Store
- Как организовать взаимодействие между несколькими stores?
- Какие операции можно вынести в derived stores?
- Как обеспечить атомарность операций?

#### История действий
- Какие данные необходимы для отмены действия?
- Как обеспечить детерминированность операций undo/redo?
- Как избежать избыточного использования памяти?

#### Синхронизация
- Как обеспечить консистентность данных при параллельных изменениях?
- Какие проблемы могут возникнуть при сохранении в localStorage?
- Как организовать очередь операций?

### 3. Вопросы для проработки edge cases

1. Консистентность данных
   - Что произойдет при undo/redo параллельных изменений?
   - Как восстановить состояние после ошибки?
   - Как обрабатывать конфликты версий?

2. Ресурсы браузера
   - Как контролировать потребление памяти?
   - Когда необходимо очищать историю действий?
   - Как избежать блокировки UI thread?

3. Пользовательский опыт
   - Как обеспечить отзывчивость UI при тяжелых операциях?
   - Какие операции требуют оптимистичного обновления?
   - Как информировать пользователя о состоянии операций?

## Интерфейсы

```typescript
interface Task {
    id: string;
    title: string;
    description: string;
    priority: Priority;
    status: Status;
    createdAt: Date;
    deadline?: Date;
    tags: string[];
    assignee?: string;
    version: number;
}

interface TaskAction {
    type: ActionType;
    payload: unknown;
    timestamp: number;
    metadata: ActionMetadata;
}

interface TaskStore {
    subscribe: (run: Subscriber<Task[]>) => Unsubscriber;
    add: (task: Omit<Task, 'id' | 'createdAt'>) => void;
    update: (id: string, changes: Partial<Task>) => void;
    remove: (id: string) => void;
    undo: () => void;
    redo: () => void;
    filter: (predicate: (task: Task) => boolean) => void;
}
```

## Критерии оценки

### Функциональные требования (40%)
- [ ] CRUD операции с поддержкой отмены
- [ ] Фильтрация и поиск по множеству критериев
- [ ] Корректная работа истории действий
- [ ] Сохранение и восстановление состояния
- [ ] Обработка конфликтов при параллельных изменениях

### Нефункциональные требования (40%)
- [ ] Время отклика UI < 16ms (60 FPS)
- [ ] Память < 50MB при 10000 задачах
- [ ] First Contentful Paint < 1s
- [ ] Time to Interactive < 2s
- [ ] Lighthouse Performance Score > 90

### Качество кода (20%)
- [ ] Полное покрытие типами
- [ ] Unit тесты > 80% покрытия
- [ ] E2E тесты критических сценариев
- [ ] Документация API и архитектуры
- [ ] Соответствие style guide

## План исследования

1. **Анализ и проектирование (День 1)**
   - Исследование паттернов управления состоянием
   - Анализ требований к производительности
   - Проектирование архитектуры

2. **Прототипирование (День 2)**
   - Создание прототипа базового функционала
   - Тестирование производительности
   - Выявление узких мест

3. **Оптимизация (День 3)**
   - Профилирование и анализ метрик
   - Исследование методов оптимизации
   - Тестирование edge cases

## Вопросы для самопроверки

### Архитектура
1. Почему выбрана именно такая структура store?
2. Как обеспечивается масштабируемость решения?
3. Какие альтернативные подходы рассматривались?

### Производительность
1. Какие метрики важны для данного приложения?
2. Где возможны проблемы с производительностью?
3. Как измерить эффективность оптимизаций?

### Надежность
1. Какие edge cases могут возникнуть?
2. Как обеспечить целостность данных?
3. Как тестировать недетерминированное поведение?

## Критерии "зачет/незачет"

### Для "зачета" необходимо:
1. Выполнить все функциональные требования
2. Достичь указанных показателей производительности
3. Обеспечить покрытие тестами > 80%
4. Корректно обрабатывать edge cases

### Критические ошибки (незачет):
1. Утечки памяти
2. Неконсистентное состояние после undo/redo
3. Потеря данных пользователя
4. Нарушение типизации
5. Блокировка UI thread

## Рекомендуемые материалы
- [Svelte Tutorial: Custom Stores](https://svelte.dev/tutorial/custom-stores)
- [Command Pattern in TypeScript](https://refactoring.guru/design-patterns/command)
- [Performance Optimization in Svelte](https://svelte.dev/docs#run-time-svelte-store)
- [Testing Reactive Systems](https://testing-library.com/docs/svelte-testing-library/intro/)
